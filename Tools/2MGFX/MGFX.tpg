// MonoGame Effect Parser
//
// For use with our fork of the "Tiny Parser Generator"
// https://github.com/SickheadGames/TinyPG
//

<% @TinyPG Namespace="TwoMGFX" Language="C#"%>

[Skip] BlockComment -> @"/\*([^*]|\*[^/])*\*/";
[Skip] Comment -> @"//[^\n\r]*";
[Skip] Whitespace -> @"[ \t\n\r]+";
[FileAndLine] LinePragma -> @"^[ \t]*#line[ \t]*(?<Line>\d*)[ \t]*(\""(?<File>[^\""\\]*(?:\\.[^\""\\]*)*)\"")?\n";

// TOKENS
[IgnoreCase] Pass -> @"pass";
[IgnoreCase] Technique -> @"technique";
[IgnoreCase] Sampler -> @"sampler1D|sampler2D|sampler3D|samplerCUBE|SamplerState|sampler";
[IgnoreCase] SamplerState -> @"sampler_state";
[IgnoreCase] VertexShader -> @"VertexShader";
[IgnoreCase] PixelShader -> @"PixelShader";
[IgnoreCase] Register -> @"register";
Number -> @"[+-] ?[0-9]?\.?[0-9]+[fF]?";
Sign -> @"-|\+";
Identifier -> @"[A-Za-z_][A-Za-z0-9_]*";
OpenBracket -> @"{";
CloseBracket -> @"}";
Equals -> @"=";
Colon -> @":";
Comma -> @",";
Semicolon -> @";";
OpenParenthesis -> @"\(";
CloseParenthesis -> @"\)";
OpenSquareBracket -> @"\[";
CloseSquareBracket -> @"\]";
LessThan -> @"<";
GreaterThan -> @">";
[IgnoreCase] Compile -> @"compile";
ShaderModel -> @"[A-Za-z_][A-Za-z0-9_]*";
Code -> @"[\S]+";
EndOfFile -> @"^$";

// Sampler states
[IgnoreCase] MinFilter -> @"MinFilter";
[IgnoreCase] MagFilter -> @"MagFilter";
[IgnoreCase] MipFilter -> @"MipFilter";
[IgnoreCase] Filter -> @"Filter";
[IgnoreCase] Texture -> @"Texture";
[IgnoreCase] AddressU -> @"AddressU";
[IgnoreCase] AddressV -> @"AddressV";
[IgnoreCase] AddressW -> @"AddressW";
[IgnoreCase] MaxAnisotropy -> @"MaxAnisotropy";
[IgnoreCase] MaxMipLevel -> @"MaxMipLevel|MaxLod";
[IgnoreCase] MipLodBias -> @"MipLodBias";

// Address Mode
[IgnoreCase] Clamp -> @"Clamp";
[IgnoreCase] Wrap -> @"Wrap";
[IgnoreCase] Mirror -> @"Mirror";

// Texture Filters
[IgnoreCase] None -> @"None";
[IgnoreCase] Linear -> @"Linear";
[IgnoreCase] Point -> @"Point";
[IgnoreCase] Anisotropic -> @"Anisotropic";


// Productions
Start -> (Code | Technique_Declaration | Sampler_Declaration)* EndOfFile
{
   var shader = new ShaderInfo();

   foreach (var node in Nodes)
      node.Eval(tree, shader);

   return shader; 
};

Technique_Declaration -> Technique Identifier? OpenBracket Pass_Declaration+ CloseBracket 
{
   var technique = new TechniqueInfo();
   technique.name = $Identifier as string ?? string.Empty;
   technique.startPos = Token.StartPos;
   technique.length = Token.Length;

   foreach (var node in Nodes)
      node.Eval(tree, technique);
   
   // Make sure we have at least one pass.
   if (technique.Passes.Count > 0)
   {
      var shaderInfo = paramlist[0] as ShaderInfo;
      shaderInfo.Techniques.Add(technique);
   }

   return null;
};

Render_State_Expression -> Identifier Equals (Identifier | Number) Semicolon
{
	var name = $Identifier[0] as string;
	var value = (string)($Identifier[1] ?? $Number);
	
	var pass = paramlist[0] as PassInfo;
	pass.ParseRenderState(name, value);
		
	return null;
};

Pass_Declaration ->	Pass Identifier? OpenBracket (VertexShader_Pass_Expression | PixelShader_Pass_Expression | Render_State_Expression)* CloseBracket 
{ 
   var pass = new PassInfo();
   pass.name = $Identifier as string ?? string.Empty;

   foreach (var node in Nodes)
      node.Eval(tree, pass);

   // We need to have a pixel or vertex shader to keep this pass.
   if (!string.IsNullOrEmpty(pass.psFunction) || !string.IsNullOrEmpty(pass.vsFunction))
   {
      var technique = paramlist[0] as TechniqueInfo;
      technique.Passes.Add(pass);
   }

   return null;
};

VertexShader_Pass_Expression -> VertexShader Equals Compile ShaderModel Identifier OpenParenthesis CloseParenthesis Semicolon
{
   var pass = paramlist[0] as PassInfo;
   pass.vsModel = $ShaderModel as string;
   pass.vsFunction = $Identifier as string;
   return null;
};

PixelShader_Pass_Expression -> PixelShader Equals Compile ShaderModel Identifier OpenParenthesis CloseParenthesis Semicolon
{
   var pass = paramlist[0] as PassInfo;
   pass.psModel = $ShaderModel as string;
   pass.psFunction = $Identifier as string;
   return null;
};

AddressMode_Clamp -> Clamp { return TextureAddressMode.Clamp; };
AddressMode_Wrap -> Wrap { return TextureAddressMode.Wrap; };
AddressMode_Mirror -> Mirror { return TextureAddressMode.Mirror; };
AddressMode -> (AddressMode_Clamp|AddressMode_Wrap|AddressMode_Mirror)
{
	return $AddressMode_Clamp ?? $AddressMode_Wrap ?? $AddressMode_Mirror;
};

TextureFilter_None -> None { return TextureFilterType.None; };
TextureFilter_Linear -> Linear { return TextureFilterType.Linear; };
TextureFilter_Point -> Point { return TextureFilterType.Point; };
TextureFilter_Anisotropic -> Anisotropic { return TextureFilterType.Anisotropic; };
TextureFilter -> (TextureFilter_None|TextureFilter_Linear|TextureFilter_Point|TextureFilter_Anisotropic)
{
	return $TextureFilter_None ?? $TextureFilter_Linear ?? $TextureFilter_Point ?? $TextureFilter_Anisotropic;
};

// Sampler States
Sampler_State_Texture -> Texture Equals (LessThan|OpenParenthesis) Identifier (GreaterThan|CloseParenthesis) Semicolon { (paramlist[0] as SamplerStateInfo).TextureName = (string)$Identifier; return null; };
Sampler_State_MinFilter -> MinFilter Equals TextureFilter Semicolon { (paramlist[0] as SamplerStateInfo).MinFilter = (TextureFilterType)$TextureFilter; return null; };
Sampler_State_MagFilter -> MagFilter Equals TextureFilter Semicolon { (paramlist[0] as SamplerStateInfo).MagFilter = (TextureFilterType)$TextureFilter; return null; };
Sampler_State_MipFilter -> MipFilter Equals TextureFilter Semicolon { (paramlist[0] as SamplerStateInfo).MipFilter = (TextureFilterType)$TextureFilter; return null; };
Sampler_State_Filter -> Filter Equals TextureFilter Semicolon { (paramlist[0] as SamplerStateInfo).Filter = (TextureFilterType)$TextureFilter; return null; };
Sampler_State_AddressU -> AddressU Equals AddressMode Semicolon { (paramlist[0] as SamplerStateInfo).AddressU = (TextureAddressMode)$AddressMode; return null; };
Sampler_State_AddressV -> AddressV Equals AddressMode Semicolon { (paramlist[0] as SamplerStateInfo).AddressV = (TextureAddressMode)$AddressMode; return null; };
Sampler_State_AddressW -> AddressW Equals AddressMode Semicolon { (paramlist[0] as SamplerStateInfo).AddressW = (TextureAddressMode)$AddressMode; return null; };
Sampler_State_MaxMipLevel -> MaxMipLevel Equals Number Semicolon { (paramlist[0] as SamplerStateInfo).MaxMipLevel = ParseTreeTools.ParseInt((string)$Number); return null; };
Sampler_State_MaxAnisotropy -> MaxAnisotropy Equals Number Semicolon { (paramlist[0] as SamplerStateInfo).MaxAnisotropy = ParseTreeTools.ParseInt((string)$Number); return null; };
Sampler_State_MipLodBias -> MipLodBias Equals Number Semicolon { (paramlist[0] as SamplerStateInfo).MipMapLevelOfDetailBias = ParseTreeTools.ParseFloat((string)$Number); return null; };


Sampler_State_Expression ->	
				Sampler_State_Texture |
				Sampler_State_MinFilter |
				Sampler_State_MagFilter |
				Sampler_State_MipFilter |
				Sampler_State_Filter |
				Sampler_State_AddressU |
				Sampler_State_AddressV |
				Sampler_State_AddressW |
				Sampler_State_MaxMipLevel |
				Sampler_State_MaxAnisotropy |
				Sampler_State_MipLodBias;

Sampler_Register_Expression -> Colon Register OpenParenthesis Identifier (Comma Identifier (OpenSquareBracket Number CloseSquareBracket)?)? CloseParenthesis
{
	return null;
};

Sampler_Declaration -> Sampler Identifier Sampler_Register_Expression* ((Equals SamplerState)? OpenBracket Sampler_State_Expression* CloseBracket Semicolon)?
{
	if ($OpenBracket == null)
		return null;
	
	var sampler = new SamplerStateInfo();
	sampler.Name = $Identifier as string;
	
	foreach (ParseNode node in Nodes)
		node.Eval(tree, sampler);

	var shaderInfo = paramlist[0] as ShaderInfo;
	shaderInfo.SamplerStates.Add(sampler.Name, sampler);

	return null;
};
